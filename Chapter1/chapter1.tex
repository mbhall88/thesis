%!TEX root = ../thesis.tex
%*******************************************************************************
%*********************************** First Chapter *****************************
%*******************************************************************************

\chapter{\textit{De novo} variant discovery in genome graphs}

\ifpdf
    \graphicspath{{Chapter1/Figs/Raster/}{Chapter1/Figs/PDF/}{Chapter1/Figs/}}
\else
    \graphicspath{{Chapter1/Figs/Vector/}{Chapter1/Figs/}}
\fi


%********************************** %First Section  **************************************
\section{Motivation}

%********************************** %Second Section  *************************************
\section{Methods}

We define a method that extends \pandora{} to allow for the discovery of variants not present in the \prg{} provided to a given run. It is implemented within the \pandora{} code base, in the C++ programming language. \\
In addition, we describe a framework for evaluating the validity of variant calls from \pandora{} and how to compare them with other methods which operate on single, linear reference sequence.

The first step in *de novo* variant discovery in genome graphs is finding the candidate regions of the graph that show evidence of dissimilarity from the sample's reads.


\subsection{Finding candidate regions}

The input required for finding candidate regions are a node, $n$, within the \pandora{} pangraph, the maximum likelihood path of both sequence and k-mers in $n$, $lmp_n$ and $kmp_n$ respectively, and a padding size $w$ for the number of positions surrounding the candidate region to retrieve. \\

We define a candidate region, $r$, as an interval within $n$ where coverage on $lmp_n$ is less than a given threshold, $c$, for more than $l$ and less than $m$ consecutive positions. We note that coverage is actually stored on $kmp_n$, but is stored for the whole k-mer. We convert the coverage on $kmp_n$ into per-position coverage on $lmp_n$ and use that for identifying low-coverage segments as just described. $m$ acts to restrict the size of variants we are able to detect. If set too large, the following steps become much slower due to the combinatorial expansion of possible paths. \\
For a given read, $s$, that has a mapping to $r$ we define $s_r$ to be the subsequence of $s$ that maps to $r$, including an extra $w$ positions either side of the mapping. We define the pileup $P_r$ as the set of all $s_r \in r$.

\subsection{Enumerating paths through candidate regions}

For $r \in R$, where $R$ is the set of all candidate regions, we construct a de Bruijn graph $G_r$ from $P_r$ using the GATB library(CITE). \\
$A_l$ and $A_r$ are defined as sets of k-mers to the left and right of $r$ in the local graph. They are anchors to allow re-insertion of new sequences, found by \textit{de novo} discovery, into the local graph. If  $\nexists a \in A_l : a \in G_r \lor \nexists a \in A_r : a \in G_r$ then we abandon \textit{de novo} discovery for $r$. We use sets of k-mers for $A_l$ and $A_r$, rather than a single anchor k-mer, to provide redundancy in the case where sequencing errors cause some anchors to not be in $G_r$. Once $G_r$ is built, and we define the start anchor k-mer, $a_l$, as the first $a_l \in A_l \land a_l \in G_r$. Likewise, we define the end anchor k-mer, $a_r$, as the first $a_r \in A_r \land a_r \in G_r$.\\

$T_r$ is the spanning tree obtained by performing depth-first search (DFS) on $G_r$, beginning from node $a_l$. $p_r$ is defined as a path, from the root node $a_l$ of $T_r$ and ending at node $a_r$, which fulfils the following two conditions:

\begin{enumerate}
  \item $p_r$ is shorter than the maximum allowed path length.
  \item No more than $k$ nodes along $p_r$ have coverage $< (n_r \times 0.1) \times e_r$, where $e_r$ is the expected k-mer coverage for $r$ and $n_r$ is the number of iterations of path enumeration for $r$.
\end{enumerate}

$V_r$ is the set of all $p_r$. If $|V_r|$ is greater than a predefined threshold, $n_r$ is incremented by 1 and $V_r$ is repopulated. If $n_r \times 0.1 = 1.0$ then \textit{de novo} discovery is abandoned for $r$.

\subsubsection{Pruning the path-space in a candidate region}

As \pandora{} operates on both accurate and error-prone sequencing reads, the number of valid paths in $G_r$ can be very large. In testing, this results in run-times beyond seven days (the longest any attempt was allowed to run). The increased run-time is due to cycles that can occur in $G_r$ and exploring paths that will never reach our required end anchor $a_r$. In order to reduce the path-space within $G_r$ we prune paths based on multiple criteria. Critically, this pruning happens at each step of the graph walk (path-building).\\
In addition to $T_r$, obtained by performing DFS on $G_r$, we produce a distance map $D_r$ that results from running reversed breadth-first search (BFS) on $G_r$, beginning from node $a_r$. We say reversed BFS as we explore the predecessors of each node, rather than the successors. $D_r$ is implemented as a binary search tree where each node in the tree represents a k-mer in $G_r$ that is reachable from $a_r$ via reversed BFS. Each node additionally has an integer attached to it that describes the shortest path from that node to $a_r$.\\
We can use $D_r$ to prune the path-space by requiring, for each node, $n \in p_r$, is $n \in D_r$ and can $a_r$ be reached from $n$ in a minimum of $i$ nodes, where $i$ is defined as the maximum allowed path length minus the number of nodes walked to reach $n$. If one of these conditions is not met, we abandon $p_r$. The advantage of this pruning process is that we never explore paths that will not reach our required end point and when caught in a cycle, we will abandon the path once we have made too many iterations around the cycle.

\subsection{Inserting new paths back into graph}

%********************************** % Third Section  *************************************
\section{Results}
\label{section1.3}

\subsection{Simulated data}

\subsubsection{Performance on SNPs}

\subsubsection{Performance on indels}

\subsection{Real data}

\subsubsection{Performance on SNPs}

\subsubsection{Performance on indels}

\subsection{Effect of different basecalling versions}

%********************************** % Fourth Section  *************************************
\section{Discussion}

%********************************** % Fifth Section  *************************************
\section{Limitations}

%********************************** % Sixth Section  *************************************
\section{Future Work}
